\documentclass{exam}
\usepackage{amsmath, amssymb, listings, parskip}
\begin{document}
    \section{Sorting}
    
    \begin{tabular}{c|cccccc}
        Algorithm&Best&Average&Worst&Stable&Adaptive&In/out-of-place\\
        \hline
        Bubble&$O(n)$&$O(n^2)$&$O(n^2)$&Yes&Yes&In\\
        Cocktail shaker&$O(n)$&$O(n^2)$&$O(n^2)$&Yes&Yes&In\\
        Insertion&$O(n)$&$O(n^2)$&$O(n^2)$&Yes&Yes&In\\
        Selection&$O(n^2)$&$O(n^2)$&$O(n^2)$&No&No&Out\\
        Merge&$O(n \log n)$&$O(n \log n)$&$O(n \log n)$&Yes&No&In
    \end{tabular}

    \textit{Comparable:} a.compareTo(b)
    
    $a > b \rightarrow > 0$
    
    $a < b \rightarrow < 0$
    
    $a == b \rightarrow = 0$
    
    \textit{Comparator:} comparator.compare(a,b)\\
    
    \textbf{Strategies:}
    
    Iterative: bubble, cocktail shaker, selection, insertion (sort)
    
    Divide and conquer: merge, LSD radix, in-place quicksort\\
    
    \textbf{Qualities:}
    
    $\bullet$ Stability: duplicates retain relative order
    
    $\bullet$ Adaptive: algorithm can end early
    
    $\bullet$ In-place: use $O(1)$ extra space or recursion. Out-of-place: use more extra space.\\
    
    \textbf{Algorithms}
    
    $\bullet$ Bubble sort:
    
    // We can apply a "no-swap" optimization so that it's not necessary to keep track of the last swap index
    
    outer loop: end to 1 (n)
    
    \qquad loop from 0 to $n-1$ (i)
    
    \qquad compare arr[i] and arr[i + 1]
    
    \qquad if not in order: swap\\
    
    $\bullet$ Cocktail shaker:
    
    // If not applying "no-swap", take into account if indices are increasing or decrasing to mark the last swap index.
    
    //That is, if they are decreasing, the last swap marker will be in the element with the smaller index, and vice-versa.
    
    outer while loop
    
    \qquad bubble sort forward
    
    \qquad bubble sort backwards
    
    \newpage
    
    $\bullet$ Insertion sort:
    
    for (i = 1 to end)
    
    \qquad curr = arr[i]

    \qquad for ($j = i - 1$ to 0)
    
    \qquad \qquad if curr $<$ arr[j]
    
    \qquad \qquad \qquad arr[j + 1] = arr[j]
    
    \qquad \qquad else
    
    \qquad \qquad \qquad arr[j + 1] = curr\\
    
    $\bullet$ Selection:
    
    for i = 0 to $n - 1$
    
    \qquad minIndex = i
    
    \qquad for $j = i + 1$ to n
    
    \qquad \qquad if arr[j] $<$ arr[minIndex]
    
    \qquad \qquad \qquad minIndex = j
    
    \qquad \qquad swap arr[i], arr[minIndex]\\
    
    $\bullet$ Selection:
    
    // Divide array into left, right sub-arrays
    
    mergesort(left)
    
    mergesort(right)
    
    merge left, right back recursively (with smaller element to the "left")
        
    \end{document}}